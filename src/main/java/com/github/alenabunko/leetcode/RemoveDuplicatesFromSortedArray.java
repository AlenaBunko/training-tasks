package com.github.alenabunko.leetcode;

/**
 * Учитывая целочисленный массив, nums отсортированный в неубывающем порядке , удалите дубликаты на месте , чтобы каждый уникальный элемент
 * появлялся только один раз . Относительный порядок элементов должен быть сохранен .
 * Поскольку в некоторых языках невозможно изменить длину массива, вместо этого вы должны поместить результат в первую часть массива nums.
 * Более формально, если есть k-элементы после удаления дубликатов, то первые k-элементы nums должны содержать окончательный результат.
 * Неважно, что вы оставите за пределами первых  k элементов.
 * Возврат k после размещения конечного результата в первых k-слотах nums .
 * Не выделяйте дополнительное пространство для другого массива. Вы должны сделать это, изменив входной массив на месте с дополнительной
 * памятью O (1).
 * Ограничения:
 * 1 <= nums.length <= 3 * 104
 * -100 <= nums[i] <= 100
 * nums сортируется в порядке неубывания .
 */

public class RemoveDuplicatesFromSortedArray {

    /**
     * Метод записывает элементы из исходного массива в новый, игнорируя дубликаты, после чего перезаписывает исходный массив элементами
     * нового, а оставшуюся часть элементов значениями по-умолчанию
     *
     * @param nums исходный массив
     * @return количество элементов без дубликатов
     */
    public int decompressRLElist(int[] nums) {
        int[] expectedNums = new int[nums.length];
        int count = 1;
        int index = 1;
        expectedNums[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] != nums[i]) {
                expectedNums[index] = nums[i];
                count++;
                index++;
            }
        }
        System.arraycopy(expectedNums, 0, nums, 0, nums.length);
        return count;
    }
}
